// Объекты: Собираем массив объектов
// В этом задании вам нужно на основании массивов с данными собрать массив объектов.
// Создайте функцию getData. У неё должно быть два параметра. Первый параметр — массив с ключами. Второй — массив с массивами данных. Ниже приведён пример такого массива.
// Функция должна собрать объект для каждого массива значений по аналогии с похожим заданием. И каждый из этих объектов должен быть записан в массив данных. Именно этот массив должна вернуть функция getData.
// Каждому элементу из массива ключей подходит элемент с таким же индексом в массиве значений. Есть один нюанс: значений может оказаться больше или меньше, чем ключей. Если значений не хватает, то создавать пустой ключ не надо. А если значений больше, то их не нужно включать в объект — для них нет ключей.

// Примерно так должен выглядеть результат работы вашей программы:

// Массив ключей
// ['имя', 'любимый цвет', 'любимое блюдо'];

// Массив значений
// [
//   ['Василий', 'красный', 'борщ'],
//   ['Мария'],
//   ['Иннокентий', 'жёлтый', 'пельмени', '18', 'Азовское']
// ];

// Готовый массив объектов
// [
//   {
//     'имя': 'Василий',
//     'любимый цвет': 'красный',
//     'любимое блюдо': 'борщ'
//   },
//   {
//     'имя': 'Мария'
//   },
//   {
//     'имя': 'Иннокентий',
//     'любимый цвет': 'жёлтый',
//     'любимое блюдо': 'пельмени'
//   }
// ];

// NOTE: Решение начало {
const projection = (meta) => (src) =>
  meta.reduce(function (dest, field, index) {
    const isFilled = Boolean(src[index]);
    if (isFilled) {
      dest[field] = src[index];
    }
    return dest;
  }, {});

const getData = (arrKeys, arrData) => {

  const p1 = projection(arrKeys);
  const arrProj = arrData.map(p1);

  return arrProj;
};

// тест. Массив ключей:
// ["name","growth","weight","age"]
// Массив значений:
// [["Пётр","165","70"],["Василий","170"],["Светлана"]]
// Ожидаемый результат:
// [{"name":"Пётр","growth":"165","weight":"70"},{"name":"Василий","growth":"170"},{"name":"Светлана"}]
// const arrKeys = ['name', 'growth', 'weight', 'age'];
// const arrData = [["Пётр","165","70"],["Василий","170"],["Светлана"]];

arrKeys = ["name", "growth", "weight", "age"];
arrData = [["Пётр", "165", "70"], ["Василий", "170"], ["Светлана"]];

const resArrOfObjects = getData(arrKeys, arrData);
console.log(resArrOfObjects);

// NOTE: } Решение окончание

// TODO: ниже кусок кода где то взятый из нэта
// смотрел как альтернативу projection из файла projection.js
// в итоге решение было скомбинировано, т.к. projection.js используется
// массив из массивов для переменной md, а в задаче обычный массив с
// ключами (следовательно не нужно делать деструктурирование в callback-е
// reduce)
//
// const users = [
//   { id: "1", name: "John" },
//   { id: "2", name: "Anna" },
//   { id: "3", name: "Kate" },
// ];

// const usernamesById = users.reduce(function (result, user) {
//   console.log("usr: ", user);
//   console.log("res: ", result);
//   return {
//     ...result,
//     [user.id]: user.name,
//   };
// }, {});
// { '1': 'John', '2': 'Anna', '3': 'Kate' }

// console.log(usernamesById);
